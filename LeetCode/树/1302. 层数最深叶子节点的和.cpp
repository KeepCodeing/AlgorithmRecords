/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
// 树专题第⑨弹，同样是套模板，不过就算如此这种题也是第一次做呢...
// 首先考虑个最朴素的做法，我们遍历一次树，然后记录这个树的最大深度，之后再遍历一次，当碰到了最大深度的节点就统计答案。
// 这样做就是要两次遍历，很可能超时，那么我们思考下能不能一次就统计完答案，事实是可以的。首先其考虑的是后序遍历，运行了
// 下好像第一次跑完所在的叶子节点的深度就是最大的，不过这样是错的，首先回忆下后续遍历的特点，它是等左右子树都遍历完了
// 才会执行别的，那我们可以认为后续遍历最后碰到的一定是叶子节点，但是它能不能保证层次最深呢？答案是不行，模拟下它的遍历
// 过程就知道了，它一开始会走到根节点的左子树的最深处，而我们默认走到最后就是叶子节点，也就是说左子树的叶子节点的值一定
// 会被当成结果值的一部分。那左子树走完了自然该走右子树了，但是右子树的高度一定比左子树小或者和左子树相同吗，答案是否定的
// 事实上不管哪种情况，右子树的叶子节点的值也一定会被作为结果的一部分计算。当我们的树的叶子节点高度相同时，这份代码确实
// 可以得到正确答案，但是如果任意一个叶子节点的高度不相同，这个份代码就一定会计算多余的部分。
// 于是我们可以考虑下如何改进，既然高度不确定，那么我们回到朴素做法，每次记录最高的高度即可。那么如何更新答案呢？我们默认
// 和为0，试想当我们当前叶子节点的高度比之前的叶子节点的高度更高时，之前的和是不是就没用了？那也就是说如果我们记录的最高
// 高度被更新了，就要把答案也置零，但是这里置零也有条件，其之前写的<=，也就是当前这一层的答案一定是先被置零才会被使用，即
// 答案永远只能记录一个叶子节点的值，正确的写法是写<，即只有第一次到这一层才置零和... 
class Solution {
public:
    int res = 0;
    int maxDepth = -1;
    void pre_order(TreeNode* root, int depth) {
        if (!root) return;
        pre_order(root->left, depth + 1);
        pre_order(root->right, depth + 1);
        // 只置零一次结果，写<=这一层的结果都会先被置零后被使用... 
        if (depth > maxDepth) maxDepth = depth, res = 0;
        if (depth == maxDepth) res += root->val;
    }
    int deepestLeavesSum(TreeNode* root) {
        pre_order(root, 0);
        return res;
    }
};
