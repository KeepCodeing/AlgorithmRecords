#include <iostream>
#include <vector>
using namespace std;

// 思路算是正确的（大嘘），其想法是对比选当前数的和大还是不选当前数和大，如果选当前数和大，则目前的最大和就是
// 之前的最大和加上当前数，如果不选当前数，则当前的最大和就是之前的最大和。
// 但是有点问题，本five设计的dp是个二维的，用i，j表示从i到j的所有数的和，那么得到的动态转移方程大概类似下面的东西
// f[i][j] = max(f[i - 1][j], f[i - 1][j] + nums[j]);但是这样就不符合题目给的O(n)时间复杂度了，虽然从01背包等问题
// 中本five知道了可以压缩状态但是还是有问题。在打表的过程中发现初始值的设置有问题，本five的两种初始值是-INF和0，
// 也就是f[0][0] = -INF或0，这样的话就会有问题，如果选的-INF，那么就没办法获得正确的值，而且对于元素为负的情况不起作用
// 如果选0，同样无法适用于当前元素为负的情况。
// 后来看了题解，大概的思路就是先把状态压缩了（没有提为什么可以那样写，不过默认是状态压缩吧..），然后初始值为nums[0]，也
// 就是不管怎么样，先把第一个元素选了再说。后面的动态转移方程就和本five的一致了，不过这只是思路之一，还有种思路就是直接
// 改nums[i]，也就是nums[i]就表示选第i个数所得到的最大和，如果当前元素大于0，也就是说最大和一定会递增，就可以选这个数，
// 否则最大和就是上一次的最大和。那么这就有点类似贪心了，当然贪心也是可以做这个题的，感觉第一次做被[i,j]之间这个概念
// 坑了，实际上从代码里并没有体现出一定就是搞个区间和之类的东西，相反当前区间和就由上次区间和转移而来。
// 那这么说可以搞个O(n^2)的前缀和，枚举i，j就行，当然这是不符合题目给的时间复杂度的.... 

// 虽然上写了一堆注释，不过还是错的w，最后的状态转移方程还是选当前数会不会导致最大和比不选当前数小 
// f[i] = max(nums[i], f[i - 1] + nums[i]);

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
		int res;
		int nLen = nums.size(); 
		if (!nLen) return 0;
		vector<int > dp(nLen + 10, 0);
		// 不管如何先把第一个数选了 
		dp[0] = nums[0];
		res = nums[0];
		for (int i = 1; i < nLen; i++) {
			// 对比下是选当前元素大还是不选当前元素大 
			dp[i] = max(nums[i], dp[i - 1] + nums[i]);
			if (dp[i] > res) res = dp[i];
		}
		return res;
    }
};

int main() {
	return 0;
}
