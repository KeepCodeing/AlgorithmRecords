#include <iostream>
using namespace std;

// 动规的基本题型有许多，比如求任意面值的硬币能组成的数值N所需的最少硬币数（某些特定额度：任意面值的硬币
// 大于比所有面值比它小的硬币的和，如1,2,4,8这种2的倍数的额度，可以用贪心解），背包问题等...

// 0/1背包就是指只有选和不选两种情况的背包问题，区别于另一类背包问题（可以选一部分的背包问题，可以用贪心解），0/1背包
// 只能用动规解

// 给定背包体积V，物品体积和价值列表，要求在物品体积和不超过V时使背包里的物品价值和最大 

struct elements {
	int value, time;
	elements(int v = 0, int t = 0) {
		value = v, time = t;
	}
};

int main() {
	// 分析：有两种情况，背包体积还够用时，背包体积不够用时，分析：当背包体积不够用了，就没办法装东西了，当背包体积
	// 够用时，我们只需要判断前面的物品价值和是否大于剩余体积减去当前物品体积加上当前物品的价值，因为如果当前物品不仅
	// 体积大，而且价值低，就不可能获得最优解 
	
	//P1048 采药
	int n, t;
	cin >> t >> n;
	elements *e = new elements[n + 1];
	for (int i = 1; i <= n; i++) {
		cin >> e[i].time >> e[i].value;
	}
	int dp[1001][101] = {0};
	for (int i = 1; i <= n; i++) {
		for (int j = t; j >= 0; j--) {
			// 决策当前是装还是不装该物品，如果之前的物品总值比装了该物品，
			// 那就没必要装，相反，如果当前装了该物品能使总值更大则减去该
			// 物品的体积 
			if (j >= e[i].time) {
				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - e[i].time] + e[i].value);
			} else {
				// 如果没有时间了，默认用之前的最优解 
				dp[i][j] = dp[i - 1][j];
			}
		}
	}
	cout << dp[n][t];
	delete[] e;
	return 0;
}
