#include <iostream>
#include <map>
using namespace std;

// 不知道能不能用普通BFS，感觉是可以的，但是如何保证花费最小呢？这个就有点麻烦了，因为BFS只能求边权唯一的图的最短路，
// 如果想用它求这种多个边权的图的最短路的话，就会很难判断第一次走到是不是就是花费最少的，从而可能要把所有可能的走法
// 的花费都对比一遍..那么考虑最短路怎么做，当前点和可以到的点建一个单向边（为什么是单向的呢？假如我们走的是右，那么
// 回来就是左，也就是边权不一样），当然还要记住上一个点的位置（应该是走法，这里倒车应该不是简单的往回走，而是说走和
// 过来方法相反的走法），然后判断是否需要倒车。 

// 打算用map做个映射，然后发现好像不可行，应该可以先BFS一遍，在这个过程里建图，然后关于转向，它应该不是说转了就一定要走的，
// 但是 
// 似乎不是最短路，而且其也搞不懂各个方向的意思... 

const int N = 40;
typedef pair<int, int > PII;
//map<PII, int > graph;
char graph[N][N];
int main() {
	int n, m, cnt = 0;
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> graph[i][j];
		}
	} 
	return 0;
}
