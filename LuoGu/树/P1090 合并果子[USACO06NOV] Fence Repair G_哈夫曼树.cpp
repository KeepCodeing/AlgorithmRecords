#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;

// 这个题用到了哈夫曼树的特点，但是和其离散里学的似乎没什么太大的关系w
// 离散里其学了两个概念，一：哈夫曼树是从一个序列里，每次选两个最小的值相加作为新节点，最后只剩一个
// 节点时就得到了哈夫曼树；二：哈夫曼树里有个最优前缀码的东西，通过给左右子树分别标上0,1然后遍历到
// 叶子，这个路径上的01序列就是最优前缀码，这个前缀码的意思就是该字符串再整个前缀码序列中都不是任意
// 一个字符的功能前缀...最后还有个题型，就是sum(层数*当前层的叶子节点的和)，得到的这个值是传输这颗
// 哈夫曼树压缩过后的编码的最小字节数（注意根节点是第0层）... 
// 那么说回这个题，它也用到了哈夫曼树的一个概念，叫带权路径和，这个东西看起来似乎就是一条从根到叶子
// 的路径的边权和，但实际上不是，它的意思是所有非叶子节点的边权和，而非叶子节点的值就是通过两个叶子
// 节点相加的来的...那么模拟这个过程就行了，因为每次构造节点都是从序列里选两个最小的元素，故而可以
// 用一个堆，当堆里的元素至少有两个的时候，就说明树还没构建完成，那么构建的过程中将节点值统计起来就行... 

// 来补充点哈夫曼树关于前缀码的知识，离散里其只知道前缀码怎么求，不知道干什么，其实这个前缀码就是为了
// 将所有字符串转换为01串然后拼接起来，用所有字符出现的次数作为叶子节点，然后构造一个哈夫曼树，这颗
// 哈夫曼树的最长带权路径长度一定是最短的，然后求前缀码，最后把前缀码拼接起来就能表示原字符串了（保证 
// 了前缀码不是任何一个字符串的前缀，故而才能拼接起来然后还能保证唯一性）。 注意前缀码不一定唯一，但
// 前缀码长度之和一定是相同的且最短的。最后注意，这种方法只能针对确定的字符串进行... 

// 注意可能会有溢出的可能，故而要开long long... 
typedef long long LL;
int main() {
	LL ans = 0;
	priority_queue<LL, vector<LL >, greater<LL > > que;
	int n, num;
	scanf("%d", &n);
	for (int i = 0; i < n; i++) scanf("%d", &num), que.push(num) ;
	while (que.size() > 1) {
		LL x, y;
		x = que.top();que.pop();
		y = que.top();que.pop();
		// 将堆顶元素加起来 
		ans += x + y;
		// 构造新节点 
		que.push(x + y); 
	}
	printf("%lld", ans);
	return 0;
}
