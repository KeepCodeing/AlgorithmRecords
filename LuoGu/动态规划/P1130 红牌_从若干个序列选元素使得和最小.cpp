#include <iostream>
#include <cstdio>
using namespace std;

// 比较有意思的一个题，做做好了w 
// 设F(i, j)表示第i天在第j组的最短时间，那么就有F(i, j) = min{F(i - 1, j - 1), F(i - 1, j)} + nums[i][j]，意思是
// 前一天在j-1个组花的时间短（即当前是从上一个组换来的），还是就在当前组花的时间短，然后加上今天在这个组花的时间，
// 注意特判第一个组，第一个组是从M那个组换过来的..（也可以搞成M组是从第一组来，这样的话上面的i - 1就改成i + 1就行了） 
// 初始条件令i == 0，1 ~ j = 0
// 打表发现每个状态确实都是这样转移过来的，都是从昨天的状态开始，要么昨天的状态没有换组，要么换组了，最后答案就是
// 最后一天转移到的状态（注意，最后一天可能在任意一个组里产生最优解，故而要遍历一遍），表里可能有多种最优方法（就
// 是说可能有多个相同的最小值，事实是表打错了，答案有没有就不知道了）

// 总结：人生真正意味上的第一道自己推的DP题，之前也有做过背包，各种模型之类的，无不例外是看题解或者背板子的...这个题
// 让其感受到了DP的魅力ww，总的来说一直学不会还是自己的原因，很多题看一眼就不想写了，DP也因此一直搁浅...希望是个好的开
// 头w 

typedef long long LL;
const int N = 2000 + 10;
int days[N][N];
LL f[N][N];
int main() {
	int n, m, pre;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			scanf("%d", &days[i][j]);
		}
	}
	// 初始化，第0天1~m组花费的时间都为0 
	for (int i = 1; i <= m; i++) f[0][i] = 0; 
	// 套dp方程，这里被坑了，表打的是按天数为第一状态，组为第二状态，然后写的时候因为输入是先组后天，所以
	// 搞反了w，跑完打印状态表才发现有点问题...然后就是想投机取巧，直接用一个变量pre来标记上一个组是哪个组，
	// 这样就能少写个判断了，然后发现这样做只有当当前组是第一组（第一组的状态可以从上一天的第三组转移而来）
	// 其这样写才有作用pre = j, if (j == 1) pre = m.. 
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			// 当前最优解就是昨天的两种状态，一，从别的组转过来，二，就在自己组继续，第一组从第三组转移 
			 if (j != 1) f[i][j] = min(f[i - 1][j], f[i - 1][j - 1]) + days[j][i];
			 else f[i][j] = min(f[i - 1][j], f[i - 1][m]) + days[j][i];
		}
	} 
	// 这里应该用INT_MAX，更保险.. 
	LL res = 1e9;
	// 统计答案... 
	for (int i = 1; i <= m; i++) res = min(res, f[n][i]);
	printf("%lld", res);
	return 0;
}
