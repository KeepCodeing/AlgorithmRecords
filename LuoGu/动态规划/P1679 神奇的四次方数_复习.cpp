#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

// 背包复习第四弹，这个题应该是个完全背包求方案数，题目没有直说可以无限选择，但是按理来说应该是可以的
// 那么就先用快速幂求出M之类的所有数，然后套模板...
// 发现套模板做不出来，然后就没想法了（无能），这个题其实可以写个爆搜，因为我们发现最多也就17个数，爆搜完全
// 可以过...
// 正解是改下完全背包统计方案的模板，或者说把统计方案做成凑数，然后对比哪一种方法凑得最少 

const int M = 100000 + 10, N = 17;
long long f[M];
int ksm (int n) {
	// 求n的四次方 
	int q = 4, res = 1;
	while (q) {
		if (q & 1) res = res * n;
		q >>= 1; // 这里最好用/，因为幂可能是负的，不过这里用不着，而且用>>比较酷w 
		n *= n;
	}
	return res;
}
// 这里把0给剔除了，因为0不可能对我们数量更少的目的起贡献 
int val[N] = {1,16,81,256,625,1296,2401,4096,6561,10000,14641,20736,28561,38416,50625,65536,83521};
int main() {
	int n;
	// 只有一个输入，能用C++的输入输出就用C++的，因为被上一个题输出格式坑了... 
	cin >> n;
	int idx = lower_bound(val, val + N, n) - val;
	// val下标从0开始，所以物品数量也该从0开始枚举，另外这里可以等于idx，因为lower_bound找到的是第一个小于等于该元素
	// 的下标，那么就算当前元素不在列表里，找到的也是比它小的元素，不会超过背包容积，就算超过了，也放不下... 
//	f[0] = 1;
	// 默认什么都不选，因为是求最小值，所以这里初始值设置为最大值 
	memset(f, 0x3f, sizeof f);
	// 选0个数就只有0总方案，注意统计方案数默认选0个物品有1种不选的方案... 
	f[0] = 0;
	for (int i = 0; i <= idx; i++) {
		for (int j = val[i]; j <= n; j++) {
			// 将统计方案数的模板改为计数 
			f[j] = min(f[j], f[j - val[i]] + 1);
		}
	}
	cout << f[n];
	return 0;
} 
