#include <iostream>
#include <cstdio>
using namespace std;

// 感觉可做w，惯例的先搞式子..设F(i, j)表示第i天第j种状态（走或不走）的最小疲劳度..
// 可以知道F(i, 0) =  min{F(i - 1, 0), F(i - 1, 1)}，而F(i, 1)则为昨天走或不走的最小疲劳乘积 
// 感觉其式子推不出来的样子w，不过很明显，这个题是个DAG，每个点都只能到其之后的点，而这些点
// 之间的边的边权就是Ci*Di， 

// F(i, j, k)，表示第i个起点第j天k状态的最小疲劳（k为0或1，不走或走），然后要注意，这个状态是分阶段的，也就是说i到i+1是一个阶段，i+1到i+2又是一个，
// 那么初始值应该互不干扰.. 

// 坠毁了，首先是k这个状态，其实可以去掉，我们考虑走其实就是昨天的距离+要走的路长，不走就是直接赋值为昨天的距离，那么对比这个就行了，而不是
// 像其一样写个三维的，而状态定义不明确... 

/*
其之前做了个叫美元汇率的题，那个题本质上有两种状态，所以选和不选产生的结果也是对于这两个状态而言的，这次做的题本质上只有一个状态，故而选和不选实
际上都是对一个状态进行操作，也就是说最后新状态一定可以从这两个状态里产生，而不是上个题不同状态对应不同新状态w，这在编码上的体现就是多了一个维度用
来标记状态1还是2w，如果像其一样硬把一个状态搞成两个，会很困惑的哦w
*/

const int N = 1000 + 10;
int f[N][N][2];
int start[N], days[N];
int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) scanf("%d", &start[i]);
	for (int i = 1; i <= m; i++) scanf("%d", &days[i]);
	// 这个循环的意思：当且前第i个起点，然后这个起点可以选择在[j, m - n + i]这个区间的天作为起点，这是找规律看出来的，因为必须得提前一些天数
	// 才能保证走到终点（这也是其之前疑惑怎么样才能保证一定能走到终点的原因） 
	// 这里把起点改成0了，这符合题意，但是要注意这样的话天数数组下标就得从0开始了，一部分原因是其表打的有问题w，所以写程序的时候有很多误差... 
	// 写转移方程的又改回来了w，因为起点为0，转移方程就变成了i + 1 -> i，而不是i - 1 -> i，故而这里起点从1开始，然后0作为特殊起点进行初始化，
	// 由此天数下标又得从1开始了w 
//	for (int i = 1; i <= m; i++) f[0][i][0] = f[0][i][1] = 0x3fffffff;
	for (int i = 1; i <= n; i++) {
		for (int j = i; j <= m - n + i; j++) {
			// cout << i - 1 << "<------>" << i << ' ' << j << endl;
			// i起点的状态由i - 1这个起点转移而来，不走，那么当前最佳状态应该就是min{F(i - 1, j - 1, 0), F(i - 1, j - 1, 1)}，意思是
			// 当第j天不走时，i起点的最小疲劳值为i - 1起点从第j-1天（为什么是第j-1天呢？因为i这个点一定是“昨天”走来的）走或不走的最小花费 
//			 f[i][j][0] = min(f[i - 1][j - 1][0], f[i - 1][j - 1][1]);
			// f[i][j][0] = f[i - 1][j - 1][1];
			// 如果走，那么第j天走的疲劳值就是i - 1到i的基础疲劳值*第j天走的疲劳值
			 f[i][j][1] = start[i] * days[j];
		}		
	}
	// 似乎不走这个状态没用，大可算出来所有走的情况，然后所谓不走，其实就是选或者不选某一天的花费w
	// 最后算出来个矩阵，在里面跑个DFS说不定能搞到最小值w.. 
	for (int i = 1; i <= n; i++) {
		for (int j = i; j <= m - n + i; j++) {
			 cout << f[i][j][0] << "<----->" << f[i][j][1] << " ";
//			cout << f[i][j][1] << ' ';
		}
		cout << endl;
	}
	return 0;
}
/*
cout << i - 1 << "<------>" << i << ' ' << j << endl;
0<------>1 1
0<------>1 2
0<------>1 3
1<------>2 2
1<------>2 3
1<------>2 4
2<------>3 3
2<------>3 4
2<------>3 5
*/
