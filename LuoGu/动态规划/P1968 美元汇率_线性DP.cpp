#include <iostream>
#include <cstdio>
using namespace std;

// 设F(i, j)表示第i天手上拿着第j种钱的最大收益，根据题目数据可以发现汇率公式：美元->马克 = 美元 * (汇率 / 100)，马克->美元 = 马克 / (汇率 / 100)
// 每天都有这几种决策：一，将美元转换为马克，或者不转，二，将马克转换为美元，或者不转，打表看下规律 
// 手玩了下发现这里的不转其实不是指直接保留昨天的状态，而是进行对比后决策的，可以得到下面的公式
// 用F(i, 0)表示第i天手上美元的最大收益，F(i, 1)表示第i天手上马克的最大收益
// 那么就有F(i, 0) = max{F(i - 1, 0), F(i - 1, 1) * 美元转马克汇率}，以及F(i, 1) = max{F(i - 1, 1), F(i - 1, 0) * 马克转美元汇率} 
// 这两个式子的意思就是不管是美元还是马克，他们都只有换或者不换两种情况，如果要使得情况更优，就一定要保证手上拿的钱是最多的，而第i
// 天手上拿的钱无非只有两种情况，i - 1天的钱换了能赚，或者不能赚，对于这两种情况，如能能赚，就换，不能赚，就不换...，然后注意题目
// 还给了一个要求，就是在最后一天结束之前要把钱换回美元，前面我们保证了第i天是最优情况，那么这个第i天的最优情况其实是有两种的，一种
// 是手里美元最优，一种是手里马克最优，针对最后一天而言，不管哪个货币的钱最优，都要求将其换为美元，故而最后一天得把最优马克换成美元
// 然后和手里的最优美元进行对比... 
// 最后考虑下初始情况，设F(0, 0) = 100, F(0, 1) = 0，这样就能保证F(1, 0) = 100, F(1, 1) = 美元转马克.. 

// 对于这个题而言必须用一维分开换美元还是换马克，因为这两种状态不是一个东西，后面做了个题用这个题的思维来坠毁了w，因为那个题虽然也是
// 选或不选，但是不管选不选，状态都是唯一的... 

const int N = 100 + 10;
int nums[N];
// 因为汇率不一定是整数故而这里用double了，不知道能不能先用int存起来，最后再把汇率还原，不过好像不行.. 
double f[N][2];
int main() {
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &nums[i]);
	// 0表示美元，1表示马克 
	f[0][0] = 100, f[0][1] = 0;
	for (int i = 1; i <= n; i++) {
		// 这里f[i - 1][0] * (nums[i] / 100.0)写反了，这个东西的意思是把美元转换成马克，而不是把马克转成美元 
		f[i][0] = max(f[i - 1][0], f[i - 1][1] / (nums[i] / 100.0));
		f[i][1] = max(f[i - 1][1], f[i - 1][0] * (nums[i] / 100.0));
	}
//	for (int i = 1; i <= n; i++) {
//		printf("%.2lf %.2lf\n", f[i][0], f[i][1]);
//	}
	printf("%.2lf", max(f[n][0], f[n][1] / (nums[n] / 100.0)));
	return 0;
}
