#include <iostream>
using namespace std;
const int N = 1010, mod = 100003;
bool graph[N][N];
int f[N][N];

// 又是模板题，啊啊，现在都可以完全默写下来了w
// 首先是最后一步，最后一步一定是(n - 1, m)或者(n, m - 1)，那么既然是统计和
// 则f[n][n] = f[n - 1][m] + f[n][m - 1]，但是要注意，这里添加了障碍这种东西
// 于是我们考虑，一共有三种点
// 对于障碍点，这种点不管怎么走，有多少种方向都走，走到的步数都是0 
// 对于只能从一种方向走过来的边界点，这种点的走法就是加上上一个点的走法
// 对于有两种方向的普通点，这种点的走法就满足状态转移方程
// 那么思考下，对于非障碍点的两种点来说，如果它们的前一步是障碍点，那么当前点能有多少种走法呢？
// 很明显，当前点的走法为0，即不能通过上一个点（方向）走到这个点，于是可以将当前点的默认值设置为
// 0，如果它两个方向都能走或者能从上一个点走，那么它的走法就是走法之和，如果它不能走，因为上一个
// 点为障碍，所以走法为0，因此也可以用状态转移方程统计走法... 

int main() {
	int n, m, x, y;
	cin >> n >> m;
	while (m--) {
		cin >> x >> y, graph[x][y] = true;
		if (x == n && y == n || x == 1 && y == 1) {
			cout << 0;
			return 0;
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (i == 1 && j == 1) {
				f[i][j] = 1;
			} else if (graph[i][j]) {
				f[i][j] = 0;
			} else {
				f[i][j] = 0;
				if (i - 1 >= 1) f[i][j] += f[i - 1][j];
				if (j - 1 >= 1) f[i][j] += f[i][j - 1];
				f[i][j] %= mod;
			}
		}
	}
	cout << f[n][n];
	return 0;
}
