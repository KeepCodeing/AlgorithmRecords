#include <iostream>
#include <cstdio>
using namespace std;

// 水题第十弹w，不过这个题用Trie写并不是很水，所以这里顺带复习下Trie 
// 之前其实没有写过Trie判断前缀之类的东西，只写过Trie判断单词是否存在，这里阐述下思路
// 因为是求公共前缀，因此我们可以任选一个字符串将其映射到Trie里，那么对于这样一个字符串
// 要做的就是记录其每一个字符出现的路径，也就是对于每个字符都进行一次标记
// 对于它之后的字符串，就可以拿来查找了，但是这里又出现了个问题，如何确定前缀长度。如果我们把Trie看成
// 一个无向图/树，那么当前公共前缀的长度其实就是目前这个字符串顺着这个树能走到那一层，于是可以设一个
// 计数变量，只要当前树上还有这个字符串的路径，就一直计数，最后返回层次，最后注意，因为是求公共前缀，
// 所以结果应该是以最短公共前缀为主.. 

const int N = 1e5 * 10 + 10, M = 30;
int son[N][15], cnt[N], idx = 0;
char str[M];
void add(char s[]) {
	int p = 0, cur;
	// 这里忘了，利用的for循环特性，s[i]为'/0'的时候会自动退出 
	for (int i = 0; s[i]; i++) {
		cur = s[i] - '0';
		// 映射路径 
		if (!son[p][cur]) son[p][cur] = ++idx;
		// 获得下一次走的地方的编号 
		p = son[p][cur];
		// 这里的计数在这个题没用用，因为要求的是路径层次，而不是字符串出现次数，之前也用这个东西
		// 判断了下前缀，但是很容易发现，这个Trie树只会做一次映射，也就意味着这个cnt里的有效元素
		// 全都为1... 
		cnt[p]++;
	}
}
int findWord(char s[]) {
	int p = 0, cur;
	int res = 0;
	for (int i = 0; s[i]; i++) {
		cur = s[i] - '0';
		// 如果没有路了，就说明这一层就是最长路径了，注意这里res的更新顺序，可以发现，如果是先走了再计数，
		// 当没路的时候就找不到上一层的标号了（这里是错的，这个思路是针对上面那个cnt的思路而言的） 
		if (!son[p][cur]) return res;
		p = son[p][cur];
		// 层数计数 
		res++;
	}
}
int main() {
	int n;
	int res = 0x3fffffff;
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		scanf("%s", &str);
		// 规定第一个字符串用来映射，其它字符串用来查找，最后的功能前缀长度一定是由最短的那个前缀决定的，其实这里也比较好想
		// 如果有一个字符串和第一个字符串完全相同，而另一个字符串只和第一个字符串的部分相同，可以发现，第二个字符串才是公共
		// 前缀长度... 
		if (i == 0) add(str);
		else res = min(res, findWord(str));
	}
	cout << res;
	return 0;
}
