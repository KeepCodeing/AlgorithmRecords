#include <iostream>
using namespace std;

// 这是一道区间划分DP
// 首先考虑坐标DP，我们发现题目的要求不是说走到哪里之类的，所以坐标DP不行
// 再考虑下序列DP，可以发现，这个题也差不多是个序列的形式
// 那么首先考虑最后一步是什么，因为题目给出了只能在A..Z之间的字母选择，所以最后一个被选择的字母一定是A...Z
// 之间的任意一个。接下来就可以得到子问题了，也就是要我们统计选第N - 1（洗标从0开始）个字母的解密方案数。接下
// 来考虑状态转移方程是什么，设f[i]为当前选择了第i个位置的字符的总解密方案数，可以得到当前总方案数就是选当
// 前字母的方案 
// 即f[i] += f[i - 1]，边界不存在，初始情况就是没有选任何字符，那么解密方式只有一种，就是空串。而f[i]应该默认为0
// 因为还没有任何解密方案。但是，考虑这么一个字符串111，如果根据我们的状态转移方程来，最终的结果是f[N] = 1，也就是
// AAA这种解密方式，但是这个字符串应该有三种解密方式，另外两种解密方式就是KA和AK，也就是把11看成一个整体就得到了K，
// 但是我们的状态转移方程只能针对一个元素使用，因此序列DP也是不可行的。

// 由此，我们考虑下记录第N-2个字符以及第N-1个字符的选法。根据上面的状态转移方程，可以得出f[i] += f[i - 1] + f[i - 2]，
// 即当前位置的字符的解密方案数是只选前一个字符串的方案数加上选前两个字符的方案数。我们考虑下什么情况可以选一个字符，
// 上面情况可以选两个字符。由题目给的映射关系来看，单个数字一定存在一个与单个字母对应的关系。而能选两个数字字符的情况
// 只有当这两个数字连在一起大于等于10并且小于等于26。由此，问题就变成了选一个字符（N-1）的方案数加上能选两个字符（N-2）
// 的方案数的总和 

class Solution {
public:
    /**
     * @param s: a string,  encoded message
     * @return: an integer, the number of ways decoding
     */
    int numDecodings(string &s) {
        // write your code here
        int sLen = s.size();
        if (sLen == 0) return 0;
        int f[110];
        f[0] = 1;
        int t;
        for (int i = 1; i <= sLen; i++) {
            f[i] = 0;
            // 这里要加个特判，因为0不在映射表里，也就是说字符0没有组成方案 
            if (s[i - 1] - '0' > 0) f[i] += f[i - 1];
            // 只有当有了两个字符后才能有对应的两个数字映射 
            if (i >= 2) {
                t = (s[i - 2] - '0') * 10 + (s[i - 1] - '0');
                // 当两个数字之和在10~26之间才有对应的字母映射 
                if (t >= 10 && t <= 26) f[i] += f[i - 2];
            }
        }
        return f[sLen];
    }
};

int main() {
	return 0;
}
