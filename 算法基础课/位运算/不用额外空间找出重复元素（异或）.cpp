#include <iostream>
using namespace std;
int arr[1001];
// 异或的性质
// 类似加法运算，但是不会进行进位，例如1^1 = 0,换成加法就是 1 + 1 = 0，1^0 = 1，换成加法就是
// 1 + 0 = 1，0^0 = 0，0 + 0 = 0，也就是说异或自己会得到0，而异或其它数会得到该数本身
// 利用这个性质，如果我们对每个数都进行一次异或，正好会把k消除，这时再利用异或的形式，对原
// 数组进行异或，因为其它数依然是其本身，所以其它数就会被消除，而因为k为0了，原数组中的k就能
// 保留下来 

// 找出数组中重复的数 
void checkNum1() {
	for (int i = 0; i < 1000; i++) {
		arr[i] = i + 1;
	}
	arr[1000] = 114;
	int x = 0;
	for (int i = 1; i < 1001; i++) {
		x ^= i;
	}
	for (int i = 0; i < 1001; i++) {
		x ^= arr[i];
		cout << x << endl;
	}
	cout << x;
}
// 找出数组中只出现过一次的数 
void checkNum2() {
	bool t = true;
	int arr[11] = {1, 1, 2, 2, 3, 3, 4, 4, 5, 6, 6};
	int x = 0;
	for (int i = 0; i < 11; i++) {
		x ^= arr[i];
	}
	cout << x;
}
int main() {
	// 异或运算解题总结
	// 该算法适用于找出“唯一一个数”类型的题目，对于找出不重复的题
	// 直接异或所有数即可，而对于找出重复的题，对其进行两次异或即可（对数组区间进行一次，对数组元素进行一次
	// 因为同一个数异或两次得0，异或三次得到的又是本身） 
	
}
