#include <iostream>
using namespace std;
// 递归的思路：可以将问题分解成更简单的问题，先解决简单问题，再将其推广到复杂问题，逐步求解 
// 假如我们要求1~10的和，我们可以将其分解为10+f(9)的和，也就是10+前9项的和
// 至于f(9)是怎么来的，我们并不关心。 

// 用递归还是迭代：如果我们能确认要递归几次，我们就可以将其改写为迭代形式，
// 因为递归的效率更低，类似于上面这种问题，就可以改写为迭代形式。如果我们
// 不能很清楚的确定递归的次数，那么就用递归形式。 

// 双管齐下解题法：当分析递推公式时，我们可以从已知条件入手，从上至下递归，但当已知条件不适合
// 从上向下递推时，我们可以在允许范围内选一个较为方便的条件从下往上递推，比如走楼梯问题，我们
// 一次可以走1,2,3阶楼梯，已知条件是我们要走到n阶楼梯，答案是有多少种走法。因为没有告诉n是多少，
// 所以我们可以把n看成1，这时f(1) = 1，再将n看为2，这时f(2) = 2，因为可以走两个1阶，也可以走一个
// 两阶，而当n=3时，我们也可以继续推，但是不妨将n=3的情况看成f(1)+f(2)，因为走到第三阶台阶的情况
// 无非就一次走两步，剩一个梯，一次走一步，剩两梯，而这两种情况在f(1),f(2)就已经解出来了，继续向下
// 推，我们发现4个楼梯时有7种走法，5个楼梯时有13种走法，结合前面的走法，可以发现f(n) = f(n-1)+
//  f(n-2)+f(n-3)，当n=1时有一种走法，当n=2时有两种走法，当n=0时，表示当前走法可以一步走完，所以
// 也算一种走法，最后，当n<0时，表示已经走完了，所以返回0 

// 递归的优/缺点：优：结构简单，更好理解，缺：效率过低，重复调用无法避免（可以通过记忆化优化，
// 但不一定通用） 
int main() {
	return 0;
}
