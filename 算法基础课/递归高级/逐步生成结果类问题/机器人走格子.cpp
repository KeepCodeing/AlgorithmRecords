#include <iostream>
using namespace std;
// 假设一个x*y大小的棋盘，有一个机器人R，它只能走格点且每次只能向下或者向右走，
// 求R到(x,y)有多少种走法（x*y不大于12） 

// 分析：乍一看以为是个图论题，然而实际上这个题并没有明确的要求地图之类的东西，
// 只是告诉了我们地图的大小。我们可以假设x=3,y=3，然后在纸上画出地图。经过观察
// 我们发现，如果要到(x,y)，首先要到(x-1,y)，或者(x,y-1)，而要到(x-1,y)
// 又得首先到(x-2,y)或者(x-1,y-1)，继续递推，我们可以发现其它点也是如此，而到达
// 终点的条件就是x == 1，或者 y == 1，数据范围较小，于是我们就可以设计一个递归来解题。 
int solve(int x, int y) {
	if (x == 1 || y == 1) return 1;
	// 这里类似于求和的递归返回，相加的其实是从终止条件开始的累加值 
	return solve(x - 1, y) + solve(x, y -1);
} 
int main() {
	cout << solve(3, 3) << endl;
	return 0;
}
