#include <iostream>
using namespace std;

// 首先，这个题和摘花生哪一题很类似，大概都是求从左上到右下的最值问题
// 但是这个题和摘花生哪一题又有所不同，首先，题目限制了移动次数，即
// 时间限制为2*n-1，另外，这个题目能走的方向也更多了。

// 首先分析下时间限制为2*n-1是什么意思
// 地图大小只有n*n那么2*n-1就意味着每次走的方向只能是向下或者向右，即
// 靠近终点的方向，因为时间限制的存在，不能走回头路，所以这里就和摘花生
// 哪一题一样了

// 其次，因为这个题是求最小值，所以还要考虑下边界问题。当在f[1][1]的时候
// 既不能从上面下来也不能从左边过来，所以起点的值就是其自己。另外，如果
// 当前处在第一列或者第一行时，f[0][j]或者f[i][0]的值默认为0，也就是说
// 如果直接套用从上走来或者从左走来，会导致当前值绝对最大，所以要特判当前
// 位置为第一行或者第一列的情况，也就是说第一行不能从上面走来，第一列不能
// 从左边走来 

const int N = 110, INF = 1e9;
int graph[N][N];
int f[N][N];
int main() {
	int n;
	cin >> n;
	for (int i =1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> graph[i][j];
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (i == 1 && j == 1) {
				// 起点没地方走 
				f[i][j] = graph[i][j];
			} else {
				// 设置一个初始值，否则f[i][j]的默认值是0，下面两种情况都会相当于没走 
				f[i][j] = INF; 
				// 可以从上面走
				if (i > 1) f[i][j] = min(f[i][j], f[i - 1][j] + graph[i][j]); 
				// 可以从左边走
				if (j > 1) f[i][j] = min(f[i][j], f[i][j - 1] + graph[i][j]); 
			}
			
		}
	} 
	cout << f[n][n];
	return 0;
}
/*
5
1 4 6 8 10
2 5 7 15 17
6 8 9 18 20
10 11 12 19 21
20 23 25 29 33

109
*/ 
