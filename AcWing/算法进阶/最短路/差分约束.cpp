#include <iostream>
using namespace std;

// 差分约束一般是用来解决类似求不等式组的可行解或者最大值，最小值的问题的算法。形如给出一个不等式组x1 <= x2 + c1，x2 <= x3 + c2
// 等等然后要求一组可行解的问题都是第一类问题。对于这种问题，我们可以将其转换为最短路或者最长路，将c1看成一个常数，那么求第一个
// 不等式就可以转换为x1这个点到x2的距离为c1，依次类推，只要最短路存在，这个方程即有解。另外要注意，这里的求法和普通最短路不同，
// 这里要求存在一个超级源点能够到达所有的边（注意是边，不是点），因为一个边就是一个解，而不能到所有点也没关系，因为可能那个点不
// 对不等式组起作用，即自由变量。但是不是所有方程组都有解，我们考虑下存在负环的情况，在最短路里，如果存在负环，当前点的最短路即
// 可被无限更新，那么转换到不等式组里就会形成类似x1 < x1的自相矛盾的式子，即如果我们建出来的图存在负环，那么方程组就无解。这种问
// 一般不会考到，差分约束的题主要是求最大值最小值的问题。
// 首先给出一个结论，如果题目要求的最大值，那么我们就跑最短路，如果题目要求的最小值，那么我们就跑最长路（最长路就是松弛判断哪里
// 把<改成了>）。那么为什么是这样呢，考虑这样一个不等式组的解 x1 <= 2, x2 <= 3, x3 <= 9，这个不等式的一个解是 x <= 2，即为该不等
// 式组的最大可行解，也就是说其实求最大值就是求一个满足所有不等式的最小值，而求最小值正好就是最短路的特性。反过来，如果有x1 >= 4,
// x2 >= 9, x3 >= 114，那么这个方程的一个最小可行解就是114，即选一个满足所有不等式的最大值，同样，最大值就是最长路的特性。这类问
// 与求解不等式组问题也有共性，他们都是通过一个超级源点建立边权为c的边来跑最短路或者最长路并且要求虚拟源点能到所有边且建出来的图
// 没有负环。 
// 这里超级源点和多起点最短路和类似，方法也是差不多的.. 
// 这里并不想给出程序了，感觉教程里的比较难懂w，还是在专题的最短路里找罢w，那种比较简单，而且也和其分析有点差距... 

int main() {
	return 0;
}
