#include <iostream>
using namespace std;

// 单调栈似乎就只能做这种题... 

// 单调栈的应用：一般是用来将某个集合的元素变得单调，也就是单调增或者单调减
// 这个题具体的实现是利用一个栈，每次循环都将某个元素的左边的元素入栈，然后
// 判断栈顶原数是否大于当前元素，如果大于，则出栈，否则就说明找到了第一个离
// 当前元素最近的小于该元素的元素 

// 这个题如果用cin，cout或者优化后的它们，都不能很快的执行完（大概1s左右，再加上cin.tie(0)）
// 速度和C输入输出差不多，但是还是慢了40ms，而使用scanf或者printf却能在(100ms)左右执行完，使
// 用c输入输出，该了 

const int N = 100010;
int stk[N];
int tt = 0;
int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		int x;
		cin >> x;
		// 当栈不为空且栈顶元素大于等于当前元素时将栈顶元素弹出
		// 这就意味着第一个元素默认没有满足要求的元素 
		while (tt && stk[tt] >= x) tt--;
		// 如果栈不为空，输出栈顶元素 
		if (tt) cout << stk[tt] << ' ';
		else cout << -1 << ' ';
		// 将输入的元素依次压入栈中，这样的话新输入的元素永远都是在栈顶优先对比的，
		// 即可保证对比的元素最近，如果栈里存在一个没有被弹出的最小值，则后面的元素
		// 最终都会与这个元素对比，而如果栈里没有这样的最小值，则栈可能被清空并且以 
		// 当前输入的值作为最小值进行对比 
		stk[++tt] = x;
	}
	return 0;
}
/*
输入样例：
5
3 4 2 7 5
输出样例：
-1 3 -1 2 2
*/
