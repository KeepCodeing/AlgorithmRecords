#include <iostream>
using namespace std;

// 同样是01背包的一个扩展，只不过这里多加了一个限制条件
// 代码上就是多了层循环，这层循环就是用来枚举这个限制的，而且不管是多少维的限制条件，都可以在
// 01背包的基础上进行扩展

// 另外限制条件的循环也是根据题目类型来的，不一定所有二维费用背包就都是01背包  

// 规律就是新增的这些个个限制条件，把它们按照背包模型写在物品数量和重量循环之间，如果是
// 01背包，就是从大到小，如果是完全背包，就是从小到大，每层循环都要遵守背包模型
// 总结就是用f[j][k]表示当前体积为j，重量为k的物品最多能获得多少收益 

const int N = 1010;
int f[N][N];
int main() {
	int n, sz, m;
	// 这里sz是背包容量，m是背包能承受的重量 
	cin >> n >> sz >> m;
	for (int i = 1; i <= n; i++) {
		int si, wei, val;
		cin >> si >> wei >> val;
		// 额外的体积限制条件 
		for (int j = sz; j >= si; j--) {
			// 重量限制条件 
			for (int k = m; k >= wei; k--) {
				// 当前体积为j，重量为k的物品装入背包最多能有多少收入 
				f[j][k] = max(f[j][k], f[j - si][k - wei] + val);
			}
		}
	}
	cout << f[sz][m];
	return 0;
} 
