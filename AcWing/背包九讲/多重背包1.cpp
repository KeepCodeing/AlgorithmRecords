#include <iostream>
using namespace std;

// 同样是在01背包的基础上做了扩展，多重背包问题限定了某个物品的数量，也就是说和01背包只能选一个或者说
// 和完全背包可以无限选有区别，但是依然可以考虑选一个的情况，选两个的情况...
// 也就是说我们可以枚举每个物品选多少个的所有情况，只要这个k个物品的价值还在可选范围内

// 代码上和01背包有所区别，但是区别不大，多出来的步骤就是枚举每个物品的个数，其余几乎和01背包相同 

// 这种朴素做法的时间复杂度在O(n^3)左右，所以只能用在数据范围
// 非常小的情况下 
const int N = 110;
int f[N]; 
int main() {
	int n, v;
	cin >> n >> v;
	for (int i = 1; i <= n; i++) {
		int vi, wi, s;
		cin >> vi >> wi >> s;
		for (int j = v; j >= 0; j--) {
			// 将每件物品的选法全部枚举出来，这里k从1开始是因为不选f[j]还是0，所以没必要从0开始 
			for (int k = 1; k <= s; k++) {
				// 如果能选k件物品，对比是选还是不选更优（防止下标出界） 
				if (k * vi <= j) {
					// 和01背包相似，都是减去价格，加上收益 
					f[j] = max(f[j], f[j - k * vi] + k * wi);
				}
			}
		}
	}
	cout << f[v];
	return 0;
}
