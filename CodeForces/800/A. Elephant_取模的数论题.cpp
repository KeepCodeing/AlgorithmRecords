#include <iostream>
using namespace std;

// 考虑一个最简单的策略，每次走五i，这样就一定能保证走的步数最少，然后如果模五为0，则说明可以用n / 5i走到，否则看模数，打表发现
// 任意一个数模五其余数都在[0, 4]之内变化，于是就可以找到解了...（本来打算写个BFS的，但一想这样也太池沼了...） 

int main() {
	int x, cnt = 0;
	cin >> x;
	// 基础步数一定是走了五i的任意倍数，然后如果不能全用五i走完（即x % 5 != 0），就说明还要走[1, 4]i... 
	cnt = x / 5;
	if (x % 5) cnt++;
	cout << cnt << endl;
	return 0;
}
